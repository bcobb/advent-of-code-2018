// Generated by BUCKLESCRIPT VERSION 4.0.7, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var compare = Caml_obj.caml_compare;

var Point = /* module */[/* compare */compare];

var PointMap = $$Map.Make(Point);

function inputLines(param) {
  return $$Array.to_list(Fs.readFileSync("resources/three.txt", "utf8").split("\n"));
}

var nullClaim = /* record */[
  /* number */0,
  /* fromLeft */0,
  /* fromTop */0,
  /* width */0,
  /* height */0
];

function claim_of_string(string) {
  var result = string.match((/^#(\d+) @ (\d+),(\d+): (\d+)x(\d+)$/));
  if (result !== null) {
    return /* record */[
            /* number */Caml_format.caml_int_of_string(Caml_array.caml_array_get(result, 1)),
            /* fromLeft */Caml_format.caml_int_of_string(Caml_array.caml_array_get(result, 2)),
            /* fromTop */Caml_format.caml_int_of_string(Caml_array.caml_array_get(result, 3)),
            /* width */Caml_format.caml_int_of_string(Caml_array.caml_array_get(result, 4)),
            /* height */Caml_format.caml_int_of_string(Caml_array.caml_array_get(result, 5))
          ];
  } else {
    return nullClaim;
  }
}

function points_of_claim(claim) {
  var leftStart = claim[/* fromLeft */1] + 1 | 0;
  var leftEnd = (leftStart + claim[/* width */3] | 0) - 1 | 0;
  var topStart = claim[/* fromTop */2] + 1 | 0;
  var topEnd = (topStart + claim[/* height */4] | 0) - 1 | 0;
  var points = /* [] */0;
  for(var x = leftStart; x <= leftEnd; ++x){
    for(var y = topStart; y <= topEnd; ++y){
      points = /* :: */[
        /* tuple */[
          x,
          y
        ],
        points
      ];
    }
  }
  return points;
}

function point_histogram(list) {
  return List.fold_left((function (map, point) {
                var exit = 0;
                var entry;
                try {
                  entry = Curry._2(PointMap[/* find */21], point, map);
                  exit = 1;
                }
                catch (exn){
                  if (exn === Caml_builtin_exceptions.not_found) {
                    return Curry._3(PointMap[/* add */3], point, 1, map);
                  } else {
                    throw exn;
                  }
                }
                if (exit === 1) {
                  return Curry._3(PointMap[/* add */3], point, entry + 1 | 0, map);
                }
                
              }), PointMap[/* empty */0], list);
}

function first_solution(param) {
  return Curry._1(PointMap[/* cardinal */15], Curry._2(PointMap[/* filter */13], (function (param, frequency) {
                    return frequency > 1;
                  }), point_histogram(List.flatten(List.map(points_of_claim, List.map(claim_of_string, inputLines(/* () */0)))))));
}

function second_solution(param) {
  var claims = List.map(claim_of_string, inputLines(/* () */0));
  var solitary_points = Curry._2(PointMap[/* filter */13], (function (param, frequency) {
          return frequency === 1;
        }), point_histogram(List.flatten(List.map(points_of_claim, claims))));
  return List.find((function (claim) {
                  return List.fold_left((function (every, point) {
                                if (every) {
                                  return Curry._2(PointMap[/* mem */2], point, solitary_points);
                                } else {
                                  return false;
                                }
                              }), true, points_of_claim(claim));
                }), claims)[/* number */0];
}

exports.Point = Point;
exports.PointMap = PointMap;
exports.inputLines = inputLines;
exports.nullClaim = nullClaim;
exports.claim_of_string = claim_of_string;
exports.points_of_claim = points_of_claim;
exports.point_histogram = point_histogram;
exports.first_solution = first_solution;
exports.second_solution = second_solution;
/* PointMap Not a pure module */
